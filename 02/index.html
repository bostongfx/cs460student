<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CS460 – Assignment 02 (XTK Cubes)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#111; }
    #r{ width:100%; height:100%; }
    .hint{ position:fixed; left:10px; bottom:10px; color:#ddd; font:12px monospace; opacity:.9; user-select:none; pointer-events:none; }
  </style>

  <!-- XTK (edge build) -->
  <script type="text/javascript" src="https://get.goXTK.com/xtk_edge.js"></script>
  <!-- Scene save/load helper (provided in 02/) -->
  <script src="loader.js"></script>
</head>
<body>
  <div id="r"></div>
  <div class="hint">Hover or click a cube • Q=hide • W=color • E=rotateX • B=spin • O=download • L=load</div>

  <script>
    // ---------- GLOBALS ----------
    window.r = window.r || null;          // keep global for loader.js
    let SELECTED_CUBE = null;
    let LAST = { x: 0, y: 0 };            // last mouse pos in canvas pixels
    let SPIN = false;

    const SIZE = 6, GAP = 2;

    // Canvas helpers (accurate picking on HiDPI)
    function getCanvas() {
      return (window.r && window.r._canvas) || document.querySelector('#r canvas') || document.querySelector('canvas');
    }
    function toCanvasXY(ev) {
      const c = getCanvas(); if (!c) return {x:0,y:0};
      const rect = c.getBoundingClientRect();
      const sx = c.width / rect.width, sy = c.height / rect.height;
      return {
        x: Math.max(0, Math.min(c.width,  (ev.clientX - rect.left) * sx)),
        y: Math.max(0, Math.min(c.height, (ev.clientY - rect.top ) * sy))
      };
    }
    function pickAt(x, y) {
      const id = window.r.pick(x, y);
      SELECTED_CUBE = id ? window.r.get(id) : null;
    }
    function ensureSelection() {
      if (!SELECTED_CUBE) pickAt(LAST.x, LAST.y);
      return !!SELECTED_CUBE;
    }

    window.onload = function () {
      // 1) Renderer
      window.r = new X.renderer3D();
      window.r.container = 'r';
      window.r.init();

      // 2) Grid of 11×11×11 cubes (1331)
      const step = SIZE + GAP;
      for (let z = -5; z < 6; z++) {
        for (let y = -5; y < 6; y++) {
          for (let x = -5; x < 6; x++) {
            const c = new X.cube();
            c.lengthX = c.lengthY = c.lengthZ = SIZE;
            c.transform.translateX(step * x);
            c.transform.translateY(step * y);
            c.transform.translateZ(step * z);
            window.r.add(c);
          }
        }
      }

      // 3) Camera
      window.r.camera.position = [0, 0, 300];

      // 4) Picking (hover + click) using canvas-pixel coords
      window.r.interactor.onMouseMove = function (ev) {
        LAST = toCanvasXY(ev);
        pickAt(LAST.x, LAST.y);
      };
      window.r.interactor.onMouseDown = function (ev) {
        LAST = toCanvasXY(ev);
        pickAt(LAST.x, LAST.y);
      };

      // 5) Keys (keydown is reliable)
      window.addEventListener('keydown', (e) => {
        const k = (e.key || '').toLowerCase();

        // No selection needed
        if (k === 'b') { SPIN = !SPIN; return; }
        if (k === 'o' && typeof download === 'function') { download(); return; }
        if (k === 'l' && typeof upload === 'function')   { upload('scene.json'); return; }

        // Selection needed
        if (!ensureSelection()) return;

        if (k === 'q')       SELECTED_CUBE.visible = false;
        else if (k === 'w')  SELECTED_CUBE.color = [Math.random(), Math.random(), Math.random()];
        else if (k === 'e')  SELECTED_CUBE.transform.rotateX(10);
      });

      // 6) Spin camera when enabled
      window.r.onRender = function () {
        if (SPIN) window.r.camera.rotate([1, 0]);
      };

      window.r.render();
    };
  </script>
</body>
</html>

<!doctype html>
<html>
    <head>
        <title> Assignment 2 bonus</title>
        <style>
            html, body {
                height: 100%; 
                margin: 0; 
                background: rgb(20, 20, 20);
            } 
            /* Makes the render fill up the whole screen */
            #scene {
                width: 100vw;
                height: 100vh;
                position: fixed;
                inset: 0;
            }
        </style>

        <!-- Gets the XTK library -->
        <script type="text/javascript" src="https://get.goXTK.com/xtk_edge.js"></script>
        <script type="text/javascript" src="./loader.js"></script>

    </head>

    <body>
        <!-- Works with filling up the whole screen -->
        <div id="scene"></div>

        <script>
            "use strict";

            var SELECTED_SPHERE; 

            let ROTATING_TIME, CAMERA_TIME = false;

            let CAMERAS = [];
            let cameraIndex = -1;

            window.onload = function() {
                // Creates the renderer
                window.r = new X.renderer3D();
                r.container = 'scene';
                r.init();
                
                // Variables to control aspects of the cube of spheres
                let numberOfSpheress = 11; // on each axis
                let varOpacity = 70; // percent

                // Calculating any other variables needed
                let spacing = 30;
                let gradientIncrement = 1 / (numberOfSpheress - 1);

                // Sets the camera starting position
                r.camera.position = [numberOfSpheress * spacing, numberOfSpheress * spacing, numberOfSpheress * spacing];
                
                // Builds the cube of spheres
                let xPos = 0;
                for (let i = 0; i <= 1; i += gradientIncrement) {
                    let yPos = 0;
                    for (let j = 0; j <= 1; j += gradientIncrement) {
                        let zPos = 0;
                        for (let k = 0; k <= 1; k += gradientIncrement) {

                            // Creates the current sphere
                            let new_sphere = new X.sphere()

                            // Edits possition, size, color, and opacity
                            new_sphere.transform.translateX(xPos);
                            new_sphere.transform.translateY(yPos);
                            new_sphere.transform.translateZ(zPos);
                            new_sphere.radius = Math.floor(Math.random() * 20) + 5;
                            new_sphere.color = [k, j, i];
                            new_sphere.opacity = varOpacity / 100;

                            // Adds the current shpere to the renderer
                            r.add(new_sphere);
                            
                            zPos += spacing;
                        }
                        yPos += spacing;
                    }
                    xPos += spacing;
                }
                

                
                r.interactor.onMouseMove = function(event) { 
                                      
                    let sphereid = r.pick(event.offsetX, event.offsetY);

                    if (sphereid != 0) {                        
                        SELECTED_SPHERE = r.get(sphereid);
                    };
                };

                r.onRender = function() {
                    if (ROTATING_TIME) {
                        // spin the camera in X direction by 1 degree
                        r.camera.rotate([1, 0]);
                    };
                };

                let interval;
                window.onkeypress = function(e) {
                    if (e.key == 'q') {
                        SELECTED_SPHERE.visible = false;
                    };
                    if (e.key == 'w') {
                        SELECTED_SPHERE.color = [Math.random(), Math.random(), Math.random()];
                    };
                    if (e.key == 'e') {
                        SELECTED_SPHERE.transform.rotateX(10);
                    };
                    if (e.key == 'b') {
                        ROTATING_TIME = !ROTATING_TIME;
                    };
                    if (e.key == 'o') {
                        download();
                    };
                    if (e.key == 'l') {
                        upload("scene.json");
                    };
                    if (e.key == 'c') {
                        CAMERAS.push(new Float32Array(r.camera.view));
                    };
                    if (e.key == 'v') {
                        CAMERA_TIME = !CAMERA_TIME;
                        if (CAMERA_TIME) {
                            cameraIndex = -1;
                            interval = setInterval(cycle, 1000);
                        } else {
                            clearInterval(interval);
                        };
                    };
                };

                function cycle() {
                    r.camera.view = new Float32Array(CAMERAS[++cameraIndex % CAMERAS.length]);
                };

                r.render(); 
            }; 
        </script>
    </body>
</html>
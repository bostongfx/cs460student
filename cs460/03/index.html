<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>A3 – Final (Flicker + Wireframe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font:16px system-ui,Arial}
    header{ text-align:center; padding:14px 0 }
    #app{ position:fixed; inset:0; top:72px } /* leave room for header */
    kbd{ padding:2px 6px; border:1px solid #888; border-bottom-width:2px; border-radius:4px; background:#111 }
    .hint{opacity:.8;text-align:center;margin-top:6px}
  </style>
</head>
<body>
  <header>
    <h1>A3 – Final (Flicker + Wireframe)</h1>
    <div class="hint">SHIFT+mouse-down to place; drag up/down to scale (color flips on sign). Keys: <kbd>F</kbd> flicker, <kbd>W</kbd> wireframe.</div>
  </header>
  <div id="app"></div>

  <!-- three.js + controls from CDN -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // ------- basic scene -------
    const el = document.getElementById('app');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, el.clientWidth/el.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 10);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(el.clientWidth, el.clientHeight);
    el.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 8, 6);
    scene.add(dir);

    // helpers (invisible plane we raycast against at z=0)
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const placePlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0 plane

    // state
    const meshes = [];   // all created meshes
    let placing = null;  // { mesh, startY }
    let FLICKER = false;
    let WIREFRAME = false;

    // utility: world point under mouse on z=0 plane
    function worldPointFromEvent(e){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const p = new THREE.Vector3();
      raycaster.ray.intersectPlane(placePlane, p);
      return p;
    }

    // create a torus-knot at pos with uniform scale s
    function addTorusKnot(pos, s=1){
      const geo = new THREE.TorusKnotGeometry(0.5, 0.18, 128, 20);
      const mat = new THREE.MeshStandardMaterial({ color: 0xff00aa, metalness: 0.2, roughness: 0.35, emissive: 0x000000 });
      mat.wireframe = WIREFRAME;
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(pos);
      m.scale.setScalar(Math.max(0.1, Math.abs(s)));
      scene.add(m);
      meshes.push(m);
      return m;
    }

    // ---- show ONE default shape so the page never looks empty ----
    addTorusKnot(new THREE.Vector3(0,0,0), 1.4);

    // interactions
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      if (!e.shiftKey) return;          // placement requires SHIFT
      const p = worldPointFromEvent(e) || new THREE.Vector3();
      const m = addTorusKnot(p, 1);
      placing = { mesh: m, startY: e.clientY };
    });

    renderer.domElement.addEventListener('pointermove', (e)=>{
      if (!placing) return;
      const dy = e.clientY - placing.startY;     // drag up/down
      let s = 1 + (-dy / 100);                   // up = bigger
      const mat = placing.mesh.material;
      if (s >= 0){
        mat.color.set('#ff00aa');
      } else {
        mat.color.set('#00ff88');
      }
      placing.mesh.scale.setScalar(Math.max(0.1, Math.abs(s)));
      // also keep it under cursor while dragging
      const p = worldPointFromEvent(e);
      if (p) placing.mesh.position.copy(p);
    });

    window.addEventListener('pointerup', ()=>{
      placing = null;
    });

    // keyboard
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (k === 'w'){
        WIREFRAME = !WIREFRAME;
        meshes.forEach(m => m.material.wireframe = WIREFRAME);
      } else if (k === 'f'){
        FLICKER = !FLICKER;
        if (!FLICKER){
          meshes.forEach(m => m.material.emissiveIntensity = 0);
        }
      }
    });

    // resize
    window.addEventListener('resize', ()=>{
      const w = el.clientWidth, h = el.clientHeight;
      camera.aspect = w / h; camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    // loop
    const clock = new THREE.Clock();
    (function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      if (FLICKER){
        const pulse = 0.5 + 0.5*Math.sin(t*6);
        meshes.forEach(m => { m.material.emissive = new THREE.Color(0xffffff); m.material.emissiveIntensity = pulse; });
      }
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>

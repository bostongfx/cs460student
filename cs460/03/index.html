<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CS460 – A3 (Final + Bonus)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font:16px system-ui,Arial}
    header{text-align:center;padding:12px 0}
    #view{width:100vw;height:74vh;display:block}
    .help{max-width:1000px;margin:6px auto;padding:0 12px}
    kbd{padding:2px 6px;border:1px solid #888;border-bottom-width:2px;border-radius:4px;background:#111}
  </style>
</head>
<body>
  <header>
    <h1>A3 – Final (Flicker + Wireframe)</h1>
    <div class="help">
      SHIFT+mouse-down to place; drag up/down to scale (color flips on sign).
      Keys: <kbd>F</kbd> flicker, <kbd>W</kbd> wireframe.
    </div>
  </header>
  <canvas id="view"></canvas>
  <script type="module">
    /* === Part 1: Scene/Camera/Controls (Three.js) === */
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js';

    const HOTPINK=0xFF69B4, GRASS=0x7CFC00;
    const PLANE_Z0=new THREE.Plane(new THREE.Vector3(0,0,1),0);
    const raycaster=new THREE.Raycaster(), mouseNDC=new THREE.Vector2();
    let renderer,scene,camera,controls,LAST=null,isDragging=false,FLICKER=false,WIRE=false;
    const TORI=[];

    const canvas=document.getElementById('view');
    renderer=new THREE.WebGLRenderer({canvas,antialias:true});
    function resize(){ const w=innerWidth,h=innerHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix(); }
    addEventListener('resize',resize);

    scene=new THREE.Scene();
    scene.background=new THREE.Color(0x000000);
    scene.add(new THREE.AmbientLight(0xffffff,0.35));
    const dir=new THREE.DirectionalLight(0xffffff,0.95); dir.position.set(200,250,200); scene.add(dir);

    camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,2000);
    camera.position.set(0,120,320);

    controls=new OrbitControls(camera,renderer.domElement); controls.enableDamping=true;

    /* === Part 2: mouse → world on z=0 plane === */
    function mouseToZ0(e){
      const r=renderer.domElement.getBoundingClientRect();
      mouseNDC.x=((e.clientX-r.left)/r.width)*2-1;
      mouseNDC.y=-((e.clientY-r.top)/r.height)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      const p=new THREE.Vector3(); raycaster.ray.intersectPlane(PLANE_Z0,p); return p;
    }

    /* === Part 3–6: place/scale torus knots, color rule === */
    renderer.domElement.onmousedown=(e)=>{
      if(!e.shiftKey) return;
      controls.enabled=false;
      const pos=mouseToZ0(e);
      const geo=new THREE.TorusKnotGeometry(8,2.2,120,16,2,3);
      const mat=new THREE.MeshStandardMaterial({color:HOTPINK, metalness:0.25, roughness:0.65, side:THREE.DoubleSide, transparent:true, wireframe:WIRE});
      const m=new THREE.Mesh(geo,mat);
      m.position.copy(pos);
      m.userData.scale=1;
      scene.add(m);
      LAST=m; isDragging=true; TORI.push(m);
    };

    renderer.domElement.onmousemove=(e)=>{
      if(!isDragging||!LAST) return;
      const delta=-e.movementY*0.01;
      let next=LAST.userData.scale+delta;
      if(Math.abs(next)<0.0001) next=next<0?-0.0001:0.0001;
      LAST.userData.scale=next;
      LAST.scale.setScalar(Math.abs(next));
      LAST.material.color.set(next<0?GRASS:HOTPINK);
    };

    onmouseup=()=>{ isDragging=false; LAST=null; controls.enabled=true; };

    /* === Part 7–8: F flicker, W wireframe === */
    onkeypress=(e)=>{
      const k=e.key.toLowerCase();
      if(k==='f') FLICKER=!FLICKER;
      if(k==='w'){ WIRE=!WIRE; for(const m of TORI){ m.material.wireframe=WIRE; m.material.needsUpdate=true; } }
    };

    /* === Render loop === */
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      if(FLICKER){
        for(const m of TORI){ m.material.opacity=0.25+Math.random()*0.75; m.material.needsUpdate=true; }
      }else{
        for(const m of TORI){ if(m.material.opacity!==1){ m.material.opacity=1; m.material.needsUpdate=true; } }
      }
      renderer.render(scene,camera);
    }
    resize(); animate();
  </script>
</body>
</html>

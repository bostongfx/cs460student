<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>A3 – Final (Flicker + Wireframe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="data:,"><!-- silence favicon 404 -->
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font:16px system-ui,Arial}
    header{ text-align:center; padding:16px 0 6px }
    #app{ position:fixed; inset:0; top:100px } /* leave room for header */
    kbd{ padding:2px 6px; border:1px solid #888; border-bottom-width:2px; border-radius:4px; background:#111 }
    .hint{opacity:.95;text-align:center;margin-top:6px}
    .hud{ position:fixed; left:10px; bottom:10px; background:#111b; border:1px solid #333; border-radius:8px; padding:8px 10px; font-size:13px }
  </style>
</head>
<body>
  <header>
    <h1>A3 – Final (Flicker + Wireframe)</h1>
    <div class="hint">
      <strong>Place/scale:</strong> hold <kbd>Shift</kbd> and press/hold trackpad, drag finger up/down to scale (color flips by sign).
      <strong>Keys:</strong> <kbd>F</kbd> flicker, <kbd>W</kbd> wireframe, <kbd>P</kbd> pattern on/off (green/pink),
      <kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd> shape (cube/sphere/torus), <kbd>0</kbd> center camera, <kbd>R</kbd> reset scene, <kbd>S</kbd> save PNG.
      <br><small>(Tip: Shift + single click also drops a shape if you use “tap to click”.)</small>
    </div>
  </header>

  <div id="app"></div>
  <div class="hud" id="hud">loading…</div>

  <script>
    /* --- Minimal robust loader: CDN only (no local files) --- */
    function loadScript(srcs, done){
      (function tryOne(i){
        if(i>=srcs.length){ console.error("Failed to load any:", srcs); return; }
        const s=document.createElement('script');
        s.src=srcs[i]; s.async=true;
        s.onload=()=>done();
        s.onerror=()=>{ console.warn("CDN failed:", srcs[i]); tryOne(i+1); };
        document.head.appendChild(s);
      })(0);
    }
    const THREE_SRCS=[
      "https://unpkg.com/three@0.161.0/build/three.min.js",
      "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"
    ];
    const ORBIT_SRCS=[
      "https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js",
      "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"
    ];
    loadScript(THREE_SRCS, ()=>loadScript(ORBIT_SRCS, main));

    function main(){
      const root=document.getElementById('app');
      const hud =document.getElementById('hud');

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(50, root.clientWidth/root.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
      renderer.setSize(root.clientWidth, root.clientHeight);
      root.appendChild(renderer.domElement);

      const controls=new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping=true;
      function centerCamera(){ controls.target.set(0,0,0); camera.position.set(0,0,9); controls.update(); }

      scene.add(new THREE.AmbientLight(0xffffff,0.65));
      const dir=new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(5,8,6); scene.add(dir);

      // Placement helpers (z=0 plane)
      const placePlane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
      const raycaster=new THREE.Raycaster();
      const pointer=new THREE.Vector2();
      function getWorldPoint(e){
        const rect=renderer.domElement.getBoundingClientRect();
        pointer.x=((e.clientX-rect.left)/rect.width)*2-1;
        pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
        raycaster.setFromCamera(pointer,camera);
        const p=new THREE.Vector3();
        return raycaster.ray.intersectPlane(placePlane,p)?p:null;
      }

      // Pattern (green/pink)
      let USE_PATTERN=false, FLICKER=false, WIREFRAME=false;
      const PINK='#ff2fb3', GREEN='#00ff66';
      function makeCheckerTexture(size=256, squares=8, cA=PINK, cB=GREEN){
        const cvs=document.createElement('canvas'); cvs.width=cvs.height=size;
        const ctx=cvs.getContext('2d'); const cell=size/squares;
        for(let y=0;y<squares;y++)for(let x=0;x<squares;x++){
          ctx.fillStyle=((x+y)%2===0)?cA:cB; ctx.fillRect(x*cell,y*cell,cell,cell);
        }
        const tex=new THREE.CanvasTexture(cvs); tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=4; return tex;
      }
      const checkerTex=makeCheckerTexture();
      function makeMaterial(color){
        const m=new THREE.MeshStandardMaterial({color, metalness:0.2, roughness:0.35, emissive:0x000000, map:USE_PATTERN?checkerTex:null});
        m.wireframe=WIREFRAME; return m;
      }

      // Shapes
      let SHAPE_MODE='torus';
      function buildGeometry(){
        if(SHAPE_MODE==='cube')   return new THREE.BoxGeometry(1.4,1.4,1.4,2,2,2);
        if(SHAPE_MODE==='sphere') return new THREE.SphereGeometry(0.9,36,24);
        return new THREE.TorusKnotGeometry(0.8,0.22,160,24);
      }

      const meshes=[];
      function addShape(pos, scale=1, sign=+1){
        const color=(sign>=0)?0xff00aa:0x00ff88;
        const mesh=new THREE.Mesh(buildGeometry(), makeMaterial(color));
        mesh.position.copy(pos);
        mesh.scale.setScalar(Math.max(0.1, Math.abs(scale)));
        scene.add(mesh); meshes.push(mesh); updateHUD(); return mesh;
      }

      // Default: one centered torus
      centerCamera(); SHAPE_MODE='torus'; addShape(new THREE.Vector3(0,0,0), 1.6, +1);

      // Placement
      let placing=null;
      renderer.domElement.addEventListener('pointerdown', e=>{
        if(!e.shiftKey) return;
        const p=getWorldPoint(e)||new THREE.Vector3(0,0,0);
        placing={ mesh:addShape(p,1,+1), startY:e.clientY };
      });
      renderer.domElement.addEventListener('pointermove', e=>{
        if(!placing) return;
        const dy=e.clientY-placing.startY, s=1+(-dy/120), sign=(s>=0)?+1:-1;
        placing.mesh.material.color.set(sign>=0?0xff00aa:0x00ff88);
        placing.mesh.scale.setScalar(Math.max(0.1, Math.abs(s)));
        const p=getWorldPoint(e); if(p) placing.mesh.position.copy(p);
      });
      window.addEventListener('pointerup', ()=>placing=null);
      renderer.domElement.addEventListener('click', e=>{
        if(!e.shiftKey || placing) return;
        const p=getWorldPoint(e)||new THREE.Vector3(0,0,0); addShape(p,1,+1);
      });

      // Keys
      window.addEventListener('keydown', e=>{
        const k=e.key.toLowerCase();
        if(k==='w'){ WIREFRAME=!WIREFRAME; meshes.forEach(m=>m.material.wireframe=WIREFRAME); updateHUD(); }
        else if(k==='f'){ FLICKER=!FLICKER; if(!FLICKER) meshes.forEach(m=>m.material.emissiveIntensity=0); updateHUD(); }
        else if(k==='p'){ USE_PATTERN=!USE_PATTERN; meshes.forEach(m=>{ m.material.map=USE_PATTERN?checkerTex:null; m.material.needsUpdate=true; }); updateHUD(); }
        else if(k==='1'){ SHAPE_MODE='cube';   updateHUD(); }
        else if(k==='2'){ SHAPE_MODE='sphere'; updateHUD(); }
        else if(k==='3'){ SHAPE_MODE='torus';  updateHUD(); }
        else if(k==='0'){ centerCamera(); }
        else if(k==='s'){ renderer.domElement.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='a3.png'; a.click(); }, 'image/png'); }
        else if(k==='r'){
          meshes.forEach(m=>scene.remove(m)); meshes.length=0;
          SHAPE_MODE='torus'; addShape(new THREE.Vector3(0,0,0), 1.6, +1);
          centerCamera(); updateHUD();
        }
      });

      function updateHUD(){
        hud.textContent=`shapes: ${meshes.length} • mode: ${SHAPE_MODE} • pattern: ${USE_PATTERN?'on':'off'} • wire: ${WIREFRAME?'on':'off'} • flicker: ${FLICKER?'on':'off'}`;
      }
      updateHUD();

      // Resize + animate
      window.addEventListener('resize', ()=>{
        const w=root.clientWidth, h=root.clientHeight;
        camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h);
      });
      const clock=new THREE.Clock();
      (function loop(){
        requestAnimationFrame(loop);
        const t=clock.getElapsedTime();
        if(FLICKER){
          const pulse=0.4+0.6*Math.max(0,Math.sin(t*6));
          meshes.forEach(m=>{ m.material.emissive=new THREE.Color(0xffffff); m.material.emissiveIntensity=pulse; });
        }
        controls.update(); renderer.render(scene,camera);
      })();
    }
  </script>
</body>
</html>
